<!doctype html>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<html>

<head>
  <style>
    body{ background-color: white; }
    canvas{ background-color: midnightblue; }
    textarea{ background-color: black;}
  </style>

  <script type="text/javascript" src="gl-matrix.js"></script>
  <script type="text/javascript" src="helpers.js"></script>
  <script type="text/javascript" src="cubo.js"></script>
  <script type="text/javascript" src="patagrua.js"></script>
  <script type="text/javascript" src="colores.js"></script>
  <script type="text/javascript" src="grua.js"></script>
  <script type="text/javascript" src="pluma.js"></script>
  <script type="text/javascript" src="mousehandle.js"></script>
  <script type="text/javascript" src="keyboardhandle.js"></script>
  <script type="text/javascript" src="cabina.js"></script>
  <script type="text/javascript" src="tapa.js"></script>
  <script type="text/javascript" src="extrusion.js"></script>
  <script type="text/javascript" src="curvaBezier.js"></script>
  <script type="text/javascript" src="barco.js"></script>
  <script type="text/javascript" src="curvaBSpline.js"></script>
  <script type="text/javascript" src="islote.js"></script>
  <script type="text/javascript" src="constantes.js"></script>
  <script type="text/javascript" src="lampara.js"></script>
  <script type="text/javascript" src="postes.js"></script>
  <script type="text/javascript" src="luces.js"></script>
  <script type="text/javascript" src="componentesuv.js"></script>
  <script type="text/javascript" src="cielo.js"></script>
  <script type="text/javascript" src="inicializarShaders.js"></script>
  <script type="text/javascript" src="start_draw.js"></script>


  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPerspectiveMatrix;

    varying highp vec4 vColor;    
  
    void main(void) {
      vec4 pos_camara = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      gl_Position =   uPerspectiveMatrix * pos_camara ;
      vColor = aVertexColor;
    }
  </script>

  <script id="shader-fs" type="x-shader/x-fragment">
    varying highp vec4 vColor;

    void main(void) {
      gl_FragColor = vColor;
    }
  </script>


  <script id="shadertexturas-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uPerspectiveMatrix;
    uniform mat3 uTextureMatrix;
    
    uniform mat3 uNormalMatrix;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;

    void main(void) {

      // Transformamos al vértice al espacio de la cámara
      pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      
      // Transformamos al vértice al espacio de la proyección
      gl_Position = uPerspectiveMatrix * pos_camera_view;
      
      // Coordenada de textura sin modifiaciones
      vTextureCoord = uTextureMatrix * vec3(aTextureCoord, 1.0);

      vNormal = normalize(uNormalMatrix*aVertexNormal);
      // vNormal = normalize(aVertexNormal);  // DEBUG
    }
  </script>

  <script id="shadertexturas-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying vec3 vPosition;

    uniform sampler2D uSampler;

    // Se hizo la luz!!!
    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;

    vec3 ads( ) {
        float Ka = 0.5;
        float Kd = 0.5;
        float Ks = 0.5;
        float Shininess = 1.0;
        vec3 LightIntensity = vec3(1.0, 1.0, 1.0);

        vec3 n = normalize( vNormal );
        vec3 s = normalize( uLightPosition - vec3(pos_camera_view) );
        vec3 v = normalize(vec3(-pos_camera_view));
        vec3 r = reflect( -s, n );
        return LightIntensity * ( Ka + Kd * max( dot(s, n), 0.0 ) + Ks * pow( max( dot(r,v), 0.0 ), Shininess ) );
    }

    void main() {
        /** DEBUG: COLOR SEGUN NORMAL **/
        // vec3 color = vec3( (vNormal.x+1.0)/2.0, (vNormal.y+1.0)/2.0, (vNormal.z+1.0)/2.0 );
        // gl_FragColor = vec4( color, 1.0);
        // return;

        /** COLOR POSTA **/
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(ads(), 1.0) * textureColor;
    }
  </script>

  <script id="shaderrelieve-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexTangent;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uPerspectiveMatrix;
    uniform mat3 uTextureMatrix;
    
    uniform mat3 uNormalMatrix;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying mat3 toLocalObject;

    void main(void) {

      // Transformamos al vértice al espacio de la cámara
      pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      
      // Transformamos al vértice al espacio de la proyección
      gl_Position = uPerspectiveMatrix * pos_camera_view;
      
      // Coordenada de textura sin modifiaciones
      vTextureCoord = uTextureMatrix * vec3(aTextureCoord, 1.0);

      vec3 normal   = normalize(uNormalMatrix * aVertexNormal);
      vec3 tangente = normalize(uNormalMatrix * aVertexTangent);
      vec3 binormal = cross (normal, tangente); //* vec3(-1.0,-1.0,-1.0);

      // // Matriz para pasar de coordenadas de vista a coordenadas tangentes(coordenadas para hacer el normal mapping)
      toLocalObject = mat3( 
          tangente.x, binormal.x, normal.x,
          tangente.y, binormal.y, normal.y,
          tangente.z, binormal.z, normal.z ) ;

      // // Matriz para pasar de coordenadas de vista a coordenadas tangentes(coordenadas para hacer el normal mapping)
      // toLocalObject = mat3( 
      //     tangente.x, tangente.x, tangente.x,
      //     binormal.y, binormal.y, binormal.y,
      //     normal.z,   normal.z,   normal.z ) ;

      vNormal = normal;
      // vNormal = normalize(aVertexNormal);  // DEBUG
    }
  </script>

  <script id="shaderrelieve-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying mat3 toLocalObject;

    uniform sampler2D uSamplerTextureMap;
    uniform sampler2D uSamplerNormalMap;

    // Se hizo la luz!!!
    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;

    vec3 ads( vec3 normalMap ) {
        float Ka = 0.5;
        float Kd = 0.5;
        float Ks = 0.8;
        float Shininess = 1.0;
        vec3 LightIntensity = vec3(1.0, 1.0, 1.0);

        vec3 n = normalize( vNormal);
        vec3 s = normalize( uLightPosition - vec3(pos_camera_view) );
        vec3 v = normalize(vec3(-pos_camera_view));
        vec3 r = reflect( -s, n );


        // Adelante
        // vec3 LightDirection = normalize( toLocalObject * s );
        // vec3 ViewDirection  = normalize( toLocalObject * v);
        // normalMap = normalize(toLocalObject * normalMap);

        // vec3 LightDirection = s;
        // vec3 ViewDirection = v;

        // Atras
        vec3 LightDirection = normalize( s * toLocalObject );
        vec3 ViewDirection  = normalize( vec3(-pos_camera_view) * toLocalObject);

        vec3 reflection = normalize(reflect( -LightDirection, normalMap ));
        float sDotN = max( dot(LightDirection, normalMap), 0.0 );   // Este es el nuevo

        // float sDotN = max( dot(s, n), 0.0 );  // Este es el viejo

        // float lightReflectionDir = max( dot(r,v), 0.0 );  // Este es el viejo
        float lightReflectionDir = max( dot(reflection, ViewDirection), 0.0 );   // Este es el nuevo
        return LightIntensity * ( Ka + Kd * sDotN + Ks * pow( lightReflectionDir, Shininess ) );
    }

    void main() {
        /** DEBUG: COLOR SEGUN NORMAL **/
        // vec3 color = vec3( (vNormal.x+1.0)/2.0, (vNormal.y+1.0)/2.0, (vNormal.z+1.0)/2.0 );
        // gl_FragColor = vec4( color, 1.0);
        // return;

        /** COLOR POSTA **/
        vec4 textureColor = texture2D(uSamplerTextureMap, vec2(vTextureCoord.s, vTextureCoord.t));

        // Obtengo los valores rgb de la textura de normal map
        vec3 nMap         = texture2D(uSamplerNormalMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb; 

        // Pase de valores rgb a valor [-1.0 ; 1.0] 
        vec3 normalMap    = (nMap * 2.0 - 1.0);

        gl_FragColor = vec4(ads(normalMap), 1.0) * textureColor;
    }
  </script>

    <script id="shaderreflection-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uPerspectiveMatrix;
    uniform mat3 uTextureMatrix;
    
    uniform mat3 uNormalMatrix;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying vec3 reflectionDir;

    void main(void) {

      // Transformamos al vértice al espacio de la cámara
      pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);

      vec3 worldCameraPosition = vec3(pos_camera_view.x, pos_camera_view.y, pos_camera_view.z);
      
      // Transformamos al vértice al espacio de la proyección
      gl_Position = uPerspectiveMatrix * pos_camera_view;
      
      // Coordenada de textura sin modifiaciones
      vTextureCoord = uTextureMatrix * vec3(aTextureCoord, 1.0);

      vec3 normal   = normalize(uNormalMatrix * aVertexNormal);

      vNormal = normal;
      // vNormal = normalize(aVertexNormal);  // DEBUG

     vec3 worldPos  = normalize( vec3( uModelMatrix * vec4(aVertexPosition,1.0) ) );
     vec3 worldNorm = normalize( vec3( uModelMatrix * vec4(aVertexNormal,  0.0) ) ); // o va normal?
     vec3 worldView = normalize( worldCameraPosition - worldPos ); // - worldPos
     reflectionDir  = normalize( reflect( -worldView, worldNorm ) );
     // if(reflectionDir.y > 1.0)  reflectionDir.y = 1.0;
     // if(reflectionDir.y < -1.0)  reflectionDir.y = -1.0;
    }


    // out vec3 ReflectDir; // The direction of the reflected ray
    // uniform bool DrawSkyBox; // Are we drawing the sky box?
    // uniform vec3 WorldCameraPosition;
    // uniform mat4 ModelViewMatrix;
    // uniform mat4 ModelMatrix;
    // uniform mat3 NormalMatrix;
    // uniform mat4 ProjectionMatrix;
    // uniform mat4 MVP;

    // void main() {
    //    if( DrawSkyBox ) {
    //        ReflectDir = VertexPosition;
    //    } else {
    //        // Compute the reflected direction in world coords.
    //        vec3 worldPos = vec3( ModelMatrix * vec4(VertexPosition,1.0) );
    //        vec3 worldNorm = vec3(ModelMatrix * vec4(VertexNormal, 0.0));
    //        vec3 worldView = normalize( WorldCameraPosition – worldPos );
    //        ReflectDir = reflect(-worldView, worldNorm );
    //        }
    //        gl_Position = MVP * vec4(VertexPosition,1.0);
    // }




  </script>

  <script id="shaderreflection-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec3 reflectionDir;


    uniform sampler2D uSamplerTextureMap;
    uniform sampler2D uSamplerReflectionMap;

    // Se hizo la luz!!!
    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;

    vec3 ads( ) {
        float Ka = 0.5;
        float Kd = 0.5;
        float Ks = 0.5;
        float Shininess = 1.0;
        vec3 LightIntensity = vec3(1.0, 1.0, 1.0);

        vec3 n = normalize( vNormal);
        vec3 s = normalize( uLightPosition - vec3(pos_camera_view) );
        vec3 v = normalize(vec3(-pos_camera_view));
        vec3 r = reflect( -s, n );

        float sDotN = max( dot(s, n), 0.0 );  // Este es el viejo

        float lightReflectionDir = max( dot(r,v), 0.0 );  // Este es el viejo
        return LightIntensity * ( Ka + Kd * sDotN + Ks * pow( lightReflectionDir, Shininess ) );
    }

    void main() {
        /** DEBUG: COLOR SEGUN NORMAL **/
        // vec3 color = vec3( (vNormal.x+1.0)/2.0, (vNormal.y+1.0)/2.0, (vNormal.z+1.0)/2.0 );
        // gl_FragColor = vec4( color, 1.0);
        // return;

        /** COLOR POSTA **/
        vec4 textureColor = texture2D(uSamplerTextureMap, vec2(vTextureCoord.s, vTextureCoord.t));

        vec4 refelctionTexture = texture2D(uSamplerReflectionMap, vec2(reflectionDir.s, reflectionDir.t) );


        gl_FragColor = mix(  textureColor , refelctionTexture, 0.3);
    }

//     vec4 cubeMapColor = texture(CubeMapTex,ReflectDir);
//  if( DrawSkyBox )
//  FragColor = cubeMapColor;
//  else
//  FragColor = mix(MaterialColor, CubeMapColor,
//  ReflectFactor);
// }
  </script>


  <script type="text/javascript">

	  var canvas;

	  var cameraMatrix      = mat4.create();
	  var perspectiveMatrix = mat4.create();
	  var camaraAux         = mat4.create();
	  var cubito            = null;
	  var cuboDos           = null;
	  var muelle            = null;
	  var mouseDown         = false;
	  var camaraCabina      = false;
	  var camaraPersona     = false;
	  var camaraGlobal      = true;
	  var mouseX            = 0.0;
	  var mouseY            = 0.0;
	  var rotarCamaraX      = 0.0;
	  var rotarCamaraY      = 0.0;
	  var aumento           = 0.0;
	  var escaladoPlumaY    = 1.0;
	  var traslacionXCabina = 0.0;
	  var traslacionPersonaX = 0.0;
	  var traslacionPersonaZ = 0.0;

	  var traslacionCamaraGlobalX = 0.0;
	  var traslacionCamaraGlobalZ = 0.0

	  var arrayContainers = [];
	  var posContainersAnterior = [];
	  var cantidadContainers = 20;
	  var containerEnganchado = -1;

	  var inicio = true;

	  var canvas = null;

	  // Variable global para el contexto GL
	  var gl;



	  function initWebGL(canvas) {
	    gl = null;
	    
	    try {
	      // Intentamos primero con el contexto estandar. Si falla, probamos con el
	      // experimental.
	      gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
	    } catch(e) {}
	    
	    // Si no tenemos un contexto, abortamos.
	    if (!gl) {
	      alert("Unable to initialize WebGL. Your browser may not support it.");
	      gl = null;
	    }
	    
	    return gl;
	  }
  
  </script>

</head>

<body onload="start()">
  <center>
      <h1>Sistemas Gr&aacute;ficos - 66.71</h1>
      <h2>WebGL - Vertex & Index buffers</h2>
      <canvas id="glcanvas" width="800" height="600">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
      </canvas>
  </center>
</body>
</html>
