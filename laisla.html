<!doctype html>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<html>

<head>
  <style>
    body{ background-color: white; }
    canvas{ background-color: midnightblue; }
    textarea{ background-color: black;}
  </style>

  <script type="text/javascript" src="gl-matrix.js"></script>
  <script type="text/javascript" src="helpers.js"></script>
  <script type="text/javascript" src="cubo.js"></script>
  <script type="text/javascript" src="patagrua.js"></script>
  <script type="text/javascript" src="colores.js"></script>
  <script type="text/javascript" src="grua.js"></script>
  <script type="text/javascript" src="pluma.js"></script>
  <script type="text/javascript" src="mousehandle.js"></script>
  <script type="text/javascript" src="keyboardhandle.js"></script>
  <script type="text/javascript" src="cabina.js"></script>
  <script type="text/javascript" src="tapa.js"></script>
  <script type="text/javascript" src="extrusion.js"></script>
  <script type="text/javascript" src="curvaBezier.js"></script>
  <script type="text/javascript" src="barco.js"></script>
  <script type="text/javascript" src="curvaBSpline.js"></script>
  <script type="text/javascript" src="islote.js"></script>
  <script type="text/javascript" src="constantes.js"></script>
  <script type="text/javascript" src="lampara.js"></script>
  <script type="text/javascript" src="postes.js"></script>
  <script type="text/javascript" src="luces.js"></script>
  <script type="text/javascript" src="componentesuv.js"></script>
  <script type="text/javascript" src="inicializarShaders.js"></script>
  <script type="text/javascript" src="start_draw.js"></script>


  <!--
  Vertex shader
  El vertex shader define la posición y forma de cada vertice de cada polígono.
  --> 
  <script id="shader-vs" type="x-shader/x-vertex">
    // Los atributos son características propias de cada vertice.
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    // Los uniforms son características propias de una etapa de dibujado completa.
    // Son comunes a todos los vertices involucrados en el dibujado.
    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPerspectiveMatrix;

    // Los varying son propiedades que toman valor para cada fragmento a partir
    // de interpolar linealmente entre los valores que se les asigna en cada 
    // vértice del polígono al cual pertenecen.
    varying highp vec4 vColor;    
  
    void main(void) {
      // gl_Position es una variable "built-in" de GLSL que es usada para 
      // almacenar la posición resultante del fragmento.
      vec4 pos_camara = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      gl_Position =   uPerspectiveMatrix * pos_camara ;
      vColor = aVertexColor;
    }
  </script>

  <script id="shadertexturas-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uPerspectiveMatrix;
    uniform mat3 uTextureMatrix;
    
        uniform mat3 uNormalMatrix;

        // Se hizo la luz!!!
        uniform vec3 uAmbientColor;
        uniform vec3 uLightPosition;
        uniform vec3 uDirectionalColor;
        uniform bool uUseLighting;


    varying vec3 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {

      // Transformamos al vértice al espacio de la cámara
      vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      
      // Transformamos al vértice al espacio de la proyección
      gl_Position = uPerspectiveMatrix * pos_camera_view;
      
      // Coordenada de textura sin modifiaciones
      vTextureCoord = uTextureMatrix * vec3(aTextureCoord, 1.0);


          ////////////////////////////////////////////
          // Calculos de la iluminación
          vec3 light_dir =  uLightPosition - vec3( pos_camera_view );
          normalize(light_dir);
          if (!uUseLighting) {
                  vLightWeighting = vec3(1.0, 1.0, 1.0);
          } else {
                  vec3 transformedNormal = normalize(uNormalMatrix * aVertexNormal);
                  float directionalLightWeighting = max(dot(transformedNormal, light_dir), 0.0);
                  vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
          }
    }
  </script>

  <!--
  Fragment shader
 
  Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
  establecer el color de cada pixel. En este caso, asignamos el color blanco a 
  cada pixel.
  -->
  <script id="shader-fs" type="x-shader/x-fragment">
    varying highp vec4 vColor;

    void main(void) {
      // gl_FragColor es una variable "built-in" de GLSL que es usada para 
      // almacenar el color resultante del fragmento.
      gl_FragColor = vColor;
    }
  </script>

  <script id="shadertexturas-fs" type="x-shader/x-fragment">
    precision mediump float;

        varying vec3 vLightWeighting;
    varying vec3 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
    }
  </script>


  <script type="text/javascript">

	  var canvas;

	  var cameraMatrix      = mat4.create();
	  var perspectiveMatrix = mat4.create();
	  var camaraAux         = mat4.create();
	  var cubito            = null;
	  var cuboDos           = null;
	  var muelle            = null;
	  var mouseDown         = false;
	  var camaraCabina      = false;
	  var camaraPersona     = false;
	  var camaraGlobal      = true;
	  var mouseX            = 0.0;
	  var mouseY            = 0.0;
	  var rotarCamaraX      = 0.0;
	  var rotarCamaraY      = 0.0;
	  var aumento           = 0.0;
	  var escaladoPlumaY    = 1.0;
	  var traslacionXCabina = 0.0;
	  var traslacionPersonaX = 0.0;
	  var traslacionPersonaZ = 0.0;

	  var traslacionCamaraGlobalX = 0.0;
	  var traslacionCamaraGlobalZ = 0.0

	  var arrayContainers = [];
	  var posContainersAnterior = [];
	  var cantidadContainers = 20;
	  var containerEnganchado = -1;

	  var inicio = true;

	  var canvas = null;

	  // Variable global para el contexto GL
	  var gl;



	  function initWebGL(canvas) {
	    gl = null;
	    
	    try {
	      // Intentamos primero con el contexto estandar. Si falla, probamos con el
	      // experimental.
	      gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
	    } catch(e) {}
	    
	    // Si no tenemos un contexto, abortamos.
	    if (!gl) {
	      alert("Unable to initialize WebGL. Your browser may not support it.");
	      gl = null;
	    }
	    
	    return gl;
	  }
  
  </script>

</head>

<body onload="start()">
  <center>
      <h1>Sistemas Gr&aacute;ficos - 66.71</h1>
      <h2>WebGL - Vertex & Index buffers</h2>
      <canvas id="glcanvas" width="800" height="600">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
      </canvas>
  </center>
</body>
</html>
