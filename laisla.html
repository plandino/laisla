<!doctype html>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<html>

<head>
  <style>
    body{ background-color: white; }
    canvas{ background-color: midnightblue; }
    textarea{ background-color: black;}
  </style>

  <script type="text/javascript" src="gl-matrix.js"></script>
  <script type="text/javascript" src="helpers.js"></script>
  <script type="text/javascript" src="cubo.js"></script>
  <script type="text/javascript" src="patagrua.js"></script>
  <script type="text/javascript" src="colores.js"></script>
  <script type="text/javascript" src="grua.js"></script>
  <script type="text/javascript" src="pluma.js"></script>
  <script type="text/javascript" src="mousehandle.js"></script>
  <script type="text/javascript" src="keyboardhandle.js"></script>
  <script type="text/javascript" src="cabina.js"></script>
  <script type="text/javascript" src="tapa.js"></script>
  <script type="text/javascript" src="extrusion.js"></script>
  <script type="text/javascript" src="curvaBezier.js"></script>
  <script type="text/javascript" src="barco.js"></script>
  <script type="text/javascript" src="curvaBSpline.js"></script>
  <script type="text/javascript" src="islote.js"></script>
  <script type="text/javascript" src="constantes.js"></script>
  <script type="text/javascript" src="lampara.js"></script>
  <script type="text/javascript" src="postes.js"></script>
  <script type="text/javascript" src="luces.js"></script>
  <script type="text/javascript" src="componentesuv.js"></script>
  <script type="text/javascript" src="cielo.js"></script>
  <script type="text/javascript" src="inicializarShaders.js"></script>
  <script type="text/javascript" src="start_draw.js"></script>


  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPerspectiveMatrix;

    varying highp vec4 vColor;    
  
    void main(void) {
      vec4 pos_camara = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      gl_Position =   uPerspectiveMatrix * pos_camara ;
      vColor = aVertexColor;
    }
  </script>

  <script id="shader-fs" type="x-shader/x-fragment">
    varying highp vec4 vColor;

    void main(void) {
      gl_FragColor = vColor;
    }
  </script>


  <script id="shadertexturas-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexTangent;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uPerspectiveMatrix;
    uniform mat3 uTextureMatrix;
    
    uniform mat3 uNormalMatrix;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying mat3 toLocalObject;

    void main(void) {

      // Transformamos al vértice al espacio de la cámara
      pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      
      // Transformamos al vértice al espacio de la proyección
      gl_Position = uPerspectiveMatrix * pos_camera_view;
      
      // Coordenada de textura sin modifiaciones
      vTextureCoord = uTextureMatrix * vec3(aTextureCoord, 1.0);

      vec3 normal   = normalize(uNormalMatrix * aVertexNormal);
      vec3 tangente = normalize(uNormalMatrix * aVertexTangent);
      vec3 binormal = cross (normal, tangente);

      // // Matriz para pasar de coordenadas de vista a coordenadas tangentes(coordenadas para hacer el normal mapping)
      toLocalObject = mat3( 
          tangente.x, binormal.x, normal.x,
          tangente.y, binormal.y, normal.y,
          tangente.z, binormal.z, normal.z ) ;

      vNormal = normal;
      // vNormal = normalize(aVertexNormal);	// DEBUG
    }
  </script>

  <script id="shadertexturas-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying mat3 toLocalObject;

    uniform sampler2D uSamplerTextureMap;
    uniform sampler2D uSamplerNormalMap;

    // Se hizo la luz!!!
    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;

    vec3 ads(  ) {
      	float Ka = 0.5;
      	float Kd = 0.5;
      	float Ks = 0.5;
      	float Shininess = 1.0;
      	vec3 LightIntensity = vec3(1.0, 1.0, 1.0);

  			vec3 n = normalize( vNormal);
  			vec3 s = normalize( uLightPosition - vec3(pos_camera_view) );
  			vec3 v = normalize(vec3(-pos_camera_view));
  			vec3 r = reflect( -s, n );

        vec3 LightDirection = normalize(s * toLocalObject);
        vec3 ViewDirection  = normalize(vec3(-pos_camera_view));

        float lightDir = dot(r,v);
  			return LightIntensity *	( Ka + Kd * max( dot(s, n), 0.0 ) + Ks * pow( max( lightDir, 0.0 ), Shininess ) );
		}

		void main() {
			  /** DEBUG: COLOR SEGUN NORMAL **/
        // vec3 color = vec3( (vNormal.x+1.0)/2.0, (vNormal.y+1.0)/2.0, (vNormal.z+1.0)/2.0 );
        // gl_FragColor = vec4( color, 1.0);
        // return;

        /** COLOR POSTA **/

        // Obtengo los valores rgb de la textura de normal map
        vec3 nMap         = texture2D(uSamplerNormalMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb; 

        // Pase de valores rgb a valor [-1.0 ; 1.0] 
        vec3 normalMap    = normalize(nMap * 2.0 - 1.0);

        vec4 textureColor = texture2D(uSamplerTextureMap, vec2(vTextureCoord.s, vTextureCoord.t));

			  gl_FragColor = vec4(ads(), 1.0) * textureColor;
		}
  </script>

  <script id="shaderrelieve-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexTangent;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uPerspectiveMatrix;
    uniform mat3 uTextureMatrix;
    
    uniform mat3 uNormalMatrix;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying mat3 toLocalObject;

    void main(void) {

      // Transformamos al vértice al espacio de la cámara
      pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      
      // Transformamos al vértice al espacio de la proyección
      gl_Position = uPerspectiveMatrix * pos_camera_view;
      
      // Coordenada de textura sin modifiaciones
      vTextureCoord = uTextureMatrix * vec3(aTextureCoord, 1.0);

      vec3 normal   = normalize(uNormalMatrix * aVertexNormal);
      vec3 tangente = normalize(uNormalMatrix * aVertexTangent);
      vec3 binormal = cross (normal, tangente);

      // // Matriz para pasar de coordenadas de vista a coordenadas tangentes(coordenadas para hacer el normal mapping)
      toLocalObject = mat3( 
          tangente.x, binormal.x, normal.x,
          tangente.y, binormal.y, normal.y,
          tangente.z, binormal.z, normal.z ) ;

      vNormal = normal;
      // vNormal = normalize(aVertexNormal);  // DEBUG
    }
  </script>

  <script id="shaderrelieve-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTextureCoord;
    varying vec4 pos_camera_view;
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying mat3 toLocalObject;

    uniform sampler2D uSamplerTextureMap;
    uniform sampler2D uSamplerNormalMap;

    // Se hizo la luz!!!
    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;

    vec3 ads(  ) {
        float Ka = 0.5;
        float Kd = 0.5;
        float Ks = 0.5;
        float Shininess = 1.0;
        vec3 LightIntensity = vec3(1.0, 1.0, 1.0);

        vec3 n = normalize( vNormal);
        vec3 s = normalize( uLightPosition - vec3(pos_camera_view) );
        vec3 v = normalize(vec3(-pos_camera_view));
        vec3 r = reflect( -s, n );

        vec3 LightDirection = normalize(s * toLocalObject);
        vec3 ViewDirection  = normalize(vec3(-pos_camera_view));

        float lightDir = dot(r,v);
        return LightIntensity * ( Ka + Kd * max( dot(s, n), 0.0 ) + Ks * pow( max( lightDir, 0.0 ), Shininess ) );
    }

    void main() {
        /** DEBUG: COLOR SEGUN NORMAL **/
        // vec3 color = vec3( (vNormal.x+1.0)/2.0, (vNormal.y+1.0)/2.0, (vNormal.z+1.0)/2.0 );
        // gl_FragColor = vec4( color, 1.0);
        // return;

        /** COLOR POSTA **/

        // Obtengo los valores rgb de la textura de normal map
        vec3 nMap         = texture2D(uSamplerNormalMap, vec2(vTextureCoord.s, vTextureCoord.t)).rgb; 

        // Pase de valores rgb a valor [-1.0 ; 1.0] 
        vec3 normalMap    = normalize(nMap * 2.0 - 1.0);

        vec4 textureColor = texture2D(uSamplerTextureMap, vec2(vTextureCoord.s, vTextureCoord.t));

        gl_FragColor = vec4(ads(), 1.0) * textureColor;
    }
  </script>


  <script type="text/javascript">

	  var canvas;

	  var cameraMatrix      = mat4.create();
	  var perspectiveMatrix = mat4.create();
	  var camaraAux         = mat4.create();
	  var cubito            = null;
	  var cuboDos           = null;
	  var muelle            = null;
	  var mouseDown         = false;
	  var camaraCabina      = false;
	  var camaraPersona     = false;
	  var camaraGlobal      = true;
	  var mouseX            = 0.0;
	  var mouseY            = 0.0;
	  var rotarCamaraX      = 0.0;
	  var rotarCamaraY      = 0.0;
	  var aumento           = 0.0;
	  var escaladoPlumaY    = 1.0;
	  var traslacionXCabina = 0.0;
	  var traslacionPersonaX = 0.0;
	  var traslacionPersonaZ = 0.0;

	  var traslacionCamaraGlobalX = 0.0;
	  var traslacionCamaraGlobalZ = 0.0

	  var arrayContainers = [];
	  var posContainersAnterior = [];
	  var cantidadContainers = 20;
	  var containerEnganchado = -1;

	  var inicio = true;

	  var canvas = null;

	  // Variable global para el contexto GL
	  var gl;



	  function initWebGL(canvas) {
	    gl = null;
	    
	    try {
	      // Intentamos primero con el contexto estandar. Si falla, probamos con el
	      // experimental.
	      gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
	    } catch(e) {}
	    
	    // Si no tenemos un contexto, abortamos.
	    if (!gl) {
	      alert("Unable to initialize WebGL. Your browser may not support it.");
	      gl = null;
	    }
	    
	    return gl;
	  }
  
  </script>

</head>

<body onload="start()">
  <center>
      <h1>Sistemas Gr&aacute;ficos - 66.71</h1>
      <h2>WebGL - Vertex & Index buffers</h2>
      <canvas id="glcanvas" width="800" height="600">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
      </canvas>
  </center>
</body>
</html>
