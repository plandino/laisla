<!doctype html>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<html>

<head>
  <style>
    body{ background-color: white; }
    canvas{ background-color: midnightblue; }
    textarea{ background-color: black;}
  </style>

  <script type="text/javascript" src="gl-matrix.js"></script>
  <script type="text/javascript" src="helpers.js"></script>
  <script type="text/javascript" src="cubo.js"></script>
  <script type="text/javascript" src="patagrua.js"></script>
  <script type="text/javascript" src="colores.js"></script>
  <script type="text/javascript" src="grua.js"></script>
  <script type="text/javascript" src="pluma.js"></script>
  <script type="text/javascript" src="mousehandle.js"></script>
  <script type="text/javascript" src="keyboardhandle.js"></script>
  <script type="text/javascript" src="cabina.js"></script>
  <script type="text/javascript" src="extrusion.js"></script>
  <script type="text/javascript" src="curvaBezier.js"></script>
  <script type="text/javascript" src="barco.js"></script>
  <script type="text/javascript" src="curvaBSpline.js"></script>
  <script type="text/javascript" src="islote.js"></script>
  <script type="text/javascript" src="constantes.js"></script>

  <!--
  Vertex shader
  El vertex shader define la posición y forma de cada vertice de cada polígono.
  --> 
  <script id="shader-vs" type="x-shader/x-vertex">
    // Los atributos son características propias de cada vertice.
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    // Los uniforms son características propias de una etapa de dibujado completa.
    // Son comunes a todos los vertices involucrados en el dibujado.
    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPerspectiveMatrix;

    // Los varying son propiedades que toman valor para cada fragmento a partir
    // de interpolar linealmente entre los valores que se les asigna en cada 
    // vértice del polígono al cual pertenecen.
    varying highp vec4 vColor;    
  
    void main(void) {
      // gl_Position es una variable "built-in" de GLSL que es usada para 
      // almacenar la posición resultante del fragmento.
      vec4 pos_camara = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
      gl_Position =   uPerspectiveMatrix * pos_camara ;
      vColor = aVertexColor;
    }
  </script>

    <script id="shadertexturas-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uModelMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uPerspectiveMatrix;
    uniform mat3 uTextureMatrix;

    varying vec3 vTextureCoord;

    void main(void) {
  
    // Transformamos al vértice al espacio de la cámara
    vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
    
    // Transformamos al vértice al espacio de la proyección
        gl_Position = uPerspectiveMatrix * pos_camera_view;
    
    // Coordenada de textura sin modifiaciones
        vTextureCoord = uTextureMatrix * vec3(aTextureCoord, 1.0);
    }
  </script>

  <!--
  Fragment shader
 
  Cada pixel en un polígono se llama fragmento. El fragment shader se encarga de
  establecer el color de cada pixel. En este caso, asignamos el color blanco a 
  cada pixel.
  -->
  <script id="shader-fs" type="x-shader/x-fragment">
    varying highp vec4 vColor;

    void main(void) {
      // gl_FragColor es una variable "built-in" de GLSL que es usada para 
      // almacenar el color resultante del fragmento.
      gl_FragColor = vColor;
    }
  </script>

  <script id="shadertexturas-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb, textureColor.a);
    }
  </script>


  <script type="text/javascript">

  var canvas;

  var cameraMatrix      = mat4.create();
  var perspectiveMatrix = mat4.create();
  var camaraAux         = mat4.create();
  var cubito            = null;
  var cuboDos           = null;
  var muelle              = null;
  var mouseDown         = false;
  var camaraCabina      = false;
  var camaraPersona     = false;
  var camaraGlobal      = true;
  var mouseX            = 0.0;
  var mouseY            = 0.0;
  var rotarCamaraX      = 0.0;
  var rotarCamaraY      = 0.0;
  var aumento           = 0.0;
  var escaladoPlumaY    = 1.0;
  var traslacionXCabina = 0.0;
  var traslacionPersonaX = 0.0;
  var traslacionPersonaZ = 0.0;

  var traslacionCamaraGlobalX = 0.0;
  var traslacionCamaraGlobalZ = 0.0

  var arrayContainers = [];
  var posContainersAnterior = [];
  var cantidadContainers = 20;
  var containerEnganchado = -1;

  var inicio = true;

  var canvas = null;

  // Variable global para el contexto GL
  var gl;

  // SHADERS FUNCTION
  function getShader(gl, id) {
    var shaderScript, src, currentChild, shader;
    
    // Obtenemos el elemento <script> que contiene el código fuente del shader.
    shaderScript = document.getElementById(id);
    if (!shaderScript) {
      return null;
    }
    
    // Extraemos el contenido de texto del <script>.
    src = "";
    currentChild = shaderScript.firstChild;
    while(currentChild) {
      if (currentChild.nodeType == currentChild.TEXT_NODE) {
        src += currentChild.textContent;
      }
      
      currentChild = currentChild.nextSibling;
    }

    // Creamos un shader WebGL según el atributo type del <script>.
    if (shaderScript.type == "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }

    // Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
    gl.shaderSource(shader, src);
    
    // Compilamos el shader.
    gl.compileShader(shader);  
      
    // Chequeamos y reportamos si hubo algún error.
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
      alert("An error occurred compiling the shaders: " + 
            gl.getShaderInfoLog(shader));  
      return null;  
    }

    return shader;
  }


  function initShadersSimple() {
    // Obtenemos los shaders ya compilados
    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");
    
    // Creamos un programa de shaders de WebGL.
    shaderProgramSimple = gl.createProgram();

    // Asociamos cada shader compilado al programa.
    gl.attachShader(shaderProgramSimple, vertexShader);
    gl.attachShader(shaderProgramSimple, fragmentShader);

    // Linkeamos los shaders para generar el programa ejecutable.
    gl.linkProgram(shaderProgramSimple);
    
    // Chequeamos y reportamos si hubo algún error.
    if (!gl.getProgramParameter(shaderProgramSimple, gl.LINK_STATUS)) {
      alert("Unable to initialize the shader program: " + 
            gl.getProgramInfoLog(shaderProgramSimple));
      return null;
    }
  
    // Le decimos a WebGL que de aquí en adelante use el programa generado.
    gl.useProgram(shaderProgramSimple);
    
    // Tomamos referencias Javascript para acceder a las variables propias 
    // del shader.
    shaderProgramSimple.vertexPositionAttribute = gl.getAttribLocation(shaderProgramSimple, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgramSimple.vertexPositionAttribute);

    shaderProgramSimple.vertexColorAttribute = gl.getAttribLocation(shaderProgramSimple, "aVertexColor");
    gl.enableVertexAttribArray(shaderProgramSimple.vertexColorAttribute);

    // Con esto accedo a las matrices uniformes del shader
    shaderProgramSimple.perspectiveMatrixUniform  = gl.getUniformLocation(shaderProgramSimple, "uPerspectiveMatrix");
    shaderProgramSimple.viewMatrixUniform         = gl.getUniformLocation(shaderProgramSimple, "uViewMatrix");
    shaderProgramSimple.modelMatrixUniform        = gl.getUniformLocation(shaderProgramSimple, "uModelMatrix");

    return shaderProgramSimple;
  }

    function initShadersConTexturas() {
    // Obtenemos los shaders ya compilados
    var fragmentShader = getShader(gl, "shadertexturas-fs");
    var vertexShader = getShader(gl, "shadertexturas-vs");
    
    // Creamos un programa de shaders de WebGL.
    shaderProgram = gl.createProgram();

    // Asociamos cada shader compilado al programa.
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);

    // Linkeamos los shaders para generar el programa ejecutable.
    gl.linkProgram(shaderProgram);
    
    // Chequeamos y reportamos si hubo algún error.
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert("Unable to initialize the shader program: " + 
            gl.getProgramInfoLog(shaderProgram));
      return null;
    }
  
    // Le decimos a WebGL que de aquí en adelante use el programa generado.
    gl.useProgram(shaderProgram);
    
    // Tomamos referencias Javascript para acceder a las variables propias 
    // del shader.
    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
    gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

    // Con esto accedo a las matrices uniformes del shader
    shaderProgram.perspectiveMatrixUniform  = gl.getUniformLocation(shaderProgram, "uPerspectiveMatrix");
    shaderProgram.viewMatrixUniform         = gl.getUniformLocation(shaderProgram, "uViewMatrix");
    shaderProgram.modelMatrixUniform        = gl.getUniformLocation(shaderProgram, "uModelMatrix");

    return shaderProgram;
  }


  function initWebGL(canvas) {
    gl = null;
    
    try {
      // Intentamos primero con el contexto estandar. Si falla, probamos con el
      // experimental.
      gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    } catch(e) {}
    
    // Si no tenemos un contexto, abortamos.
    if (!gl) {
      alert("Unable to initialize WebGL. Your browser may not support it.");
      gl = null;
    }
    
    return gl;
  }

  // DRAW 
  var t = 0.0;
  function drawScene() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
    // Preparamos una matriz de perspectiva.
    mat4.perspective(perspectiveMatrix, degToRad(88), 640.0/480.0, 0.01, 2000.0);
    // Mando la matriz de perspectiva
    gl.uniformMatrix4fv(gl.shaderProgramSimple.perspectiveMatrixUniform, false, perspectiveMatrix);
    
    // Preparamos una matriz de camara(vista).
    mat4.identity(cameraMatrix);

    var matrix_muelle = mat4.create();
    mat4.identity(matrix_muelle);
    mat4.translate(matrix_muelle, matrix_muelle, [-90.0, -8.0, -20.0]);
    muelle.draw(matrix_muelle, gl, shaderProgramSimple);

    if(inicio == true){
        for(var j = 0; j < cantidadContainers * 5 / 6; j++){
          var matrix_containers = mat4.create();
          mat4.identity(matrix_containers);
          mat4.translate(matrix_containers, matrix_containers, [ - 10.0 + 18.0 * (j % 2), 2.0, ( (j % 5) - 2) * 50.0]);
          // mat4.translate(matrix_containers, matrix_containers, [ 15.0 * j , 0.0,  50.0]);
          posContainersAnterior.push(matrix_containers);
        }

        for(var j = cantidadContainers * 5 / 6; j < cantidadContainers; j++){
          var matrix_containers = mat4.create();
          mat4.identity(matrix_containers);
          mat4.translate(matrix_containers, matrix_containers, [ 65.0 + 18.0 * (j % 2), 8.1, ( (j % 5) - 2) * 45.0 - 10.0 ] );
          // mat4.translate(matrix_containers, matrix_containers, [ 15.0 * j , 0.0,  50.0]);
          posContainersAnterior.push(matrix_containers);
        }


        inicio = false;
    } else {
          for(var j = 0; j < cantidadContainers; j++){
          matrix_containers = posContainersAnterior[j];
          if(j == containerEnganchado){
            mat4.identity(matrix_containers);
            mat4.translate(matrix_containers, matrix_containers, [35.0 + traslacionXCabina,  ((1.71 - escaladoPlumaY) * (25.0 / 1) ), trasGruaZ]);
            posContainersAnterior[j] = matrix_containers;
          }
          posContainersAnterior[j] = matrix_containers;
          arrayContainers[j].draw(matrix_containers, gl, shaderProgramSimple);
          posContainersAnterior[j] = matrix_containers;
        }

    }

    mat4.identity(camaraAux);

    if(camaraGlobal){
      mat4.lookAt(cameraMatrix, [0.0, 20.0, 150.0 + aumento], [0,0,0], [0,1,0]); // This is the key line
      mat4.rotateX(cameraMatrix, cameraMatrix, degToRad(rotarCamaraX));
      mat4.rotateY(cameraMatrix, cameraMatrix, degToRad(rotarCamaraY));
      gl.uniformMatrix4fv(gl.shaderProgramSimple.viewMatrixUniform, false, cameraMatrix );
    }

    if(camaraPersona){
      mat4.lookAt(cameraMatrix, [ traslacionPersonaX, 10.0, 10.0 + traslacionPersonaZ], [traslacionPersonaX,10.0, traslacionPersonaZ - 1.0], [0,1,0]);
      mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
      mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
      mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);
      // console.log(cameraMatrix);
      gl.uniformMatrix4fv(gl.shaderProgramSimple.viewMatrixUniform, false, cameraMatrix );
    } 

    if(camaraCabina){

      mat4.lookAt(cameraMatrix, [36.5 + traslacionXCabina, 51.4, trasGruaZ], [1000, 51.4, trasGruaZ], [0,1,0]);
      mat4.rotateX(camaraAux, camaraAux, degToRad(rotarCamaraX));
      mat4.rotateY(camaraAux, camaraAux, degToRad(rotarCamaraY));
      mat4.multiply(cameraMatrix, camaraAux, cameraMatrix);

      gl.uniformMatrix4fv(gl.shaderProgramSimple.viewMatrixUniform, false, cameraMatrix );
    }

    var matrix_grua = mat4.create();
    mat4.identity(matrix_grua);
    mat4.translate(matrix_grua, matrix_grua, [0.0, 0.0, trasGruaZ]);
    gruita.draw(matrix_grua, gl, shaderProgramSimple);

    var matrix_estructPuente = mat4.create();
    mat4.identity(matrix_estructPuente);
    mat4.translate(matrix_estructPuente, matrix_estructPuente, [trasEstructuraPuenteX, trasEstructuraPuenteY, trasEstructuraPuenteZ]);
    estructuraPuenteBarco.draw(matrix_estructPuente, gl, shaderProgramSimple);

    // Usando la misma matriz subo la cabina de mando del puente del barco
    mat4.translate(matrix_estructPuente, matrix_estructPuente, [0.0, trasCabinaDeMandoBarcoY, 0.0]);
    puenteBarco.draw(matrix_estructPuente, gl, shaderProgramSimple);

    var matrix_mar = mat4.create();
    mat4.identity(matrix_mar);
    mat4.translate(matrix_mar, matrix_mar, [0.0, -10.0, 0.0]);
    mar.draw(matrix_mar, gl, shaderProgramSimple);

    var matrix_barco = mat4.create();
    mat4.identity(matrix_barco);
    mat4.translate(matrix_barco, matrix_barco, [trasBarcoX, trasBarcoY, trasBarcoZ]);
    mat4.rotateX(matrix_barco, matrix_barco, degToRad(90));
    mat4.scale(matrix_barco, matrix_barco, [escBarcoX, escBarcoY, escBarcoZ]);
    barco.draw(matrix_barco, gl, shaderProgramSimple);

    var matrix_islote = mat4.create();
    mat4.identity(matrix_islote);
    mat4.translate(matrix_islote, matrix_islote, [20.0, -8.0, -400.0]);
    mat4.rotateX(matrix_islote, matrix_islote, degToRad(90));
    mat4.scale(matrix_islote, matrix_islote, [4.0, 3.0, 3.0]);
    islote.draw(matrix_islote, gl, shaderProgramSimple);

    t = t + 0.01;
  }

  // INIT
  function start() {
    var canvas = document.getElementById("glcanvas");

    // Inicializamos el contexto GL
    gl = initWebGL(canvas);      
    if (!gl)
      return;

    // Compilamos y linkeamos los shaders
    gl.shaderProgramSimple = initShadersSimple();
    if (!gl.shaderProgramSimple)
      return;
    
    // Color de fondo para la escena 
    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    gl.enable(gl.DEPTH_TEST);                              
    gl.depthFunc(gl.LEQUAL); 
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    gl.viewport(0, 0, canvas.width, canvas.height);


    gruita = new grua(1.0, 1.0, 1.0);
    gruita.initBuffers(gl, shaderProgramSimple);

    muelle = new cubo(muelleX, muelleY, muelleZ );
    muelle.initBuffers(gl, shaderProgramSimple, "gris");

    estructuraPuenteBarco = new cubo(estructuraPuenteX, estructuraPuenteY, estructuraPuenteZ);
    estructuraPuenteBarco.initBuffers(gl, shaderProgramSimple, "gris");

    puenteBarco = new cubo(cabinaDeMandoX, cabinaDeMandoY, cabinaDeMandoZ);
    puenteBarco.initBuffers(gl, shaderProgramSimple, "gris");

    mar = new cubo(marX, marY, marZ);
    mar.initBuffers(gl, shaderProgramSimple, "blue");

    for(var i = 0; i < cantidadContainers; i++){
      var container = new cubo(containersX, containersY, containersZ);
      container.initBuffers(gl, shaderProgramSimple, "purple");
      arrayContainers.push(container);
    }

    barco = new barco(1.0, 1.0, 1.0);
    barco.initBuffers(gl, shaderProgramSimple, "red");

    islote = new islote();
    islote.initBuffers(gl, shaderProgramSimple, "brown");

    setInterval(drawScene, 10);
  }
  </script>

</head>

<body onload="start()">
  <center>
      <h1>Sistemas Gr&aacute;ficos - 66.71</h1>
      <h2>WebGL - Vertex & Index buffers</h2>
      <canvas id="glcanvas" width="800" height="600">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
      </canvas>
  </center>
</body>
</html>
